package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"fmt"
	"scrapping_service/internal/scrapping/graph/models"
	"scrapping_service/internal/scrapping/graph/server"
	"scrapping_service/pkg/middlewares"
	"strconv"
)

// Like is the resolver for the like field.
func (r *mutationResolver) Like(ctx context.Context, article int) (*models.LikePayload, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	err = r.Scrapping.Like(ctx, userId, article)
	if err != nil {
		return nil, err
	}
	return &models.LikePayload{Status: models.StatusSuccess}, nil
}

// Unlike is the resolver for the unlike field.
func (r *mutationResolver) Unlike(ctx context.Context, article int) (*models.UnlikePayload, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	err = r.Scrapping.Unlike(ctx, userId, article)
	if err != nil {
		return nil, err
	}
	return &models.UnlikePayload{Status: models.StatusSuccess}, nil
}

// Articles is the resolver for the articles field.
func (r *queryResolver) Articles(ctx context.Context, page int, pageSize int) (*models.ArticlesPagination, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	articles, pagination, err := r.Scrapping.GetArticles(ctx, userId, page, pageSize)
	if err != nil {
		return nil, fmt.Errorf("GetArticles from scrapping error: %v", err)
	}

	result := make([]*models.ArticleInfo, 0, len(articles))
	for _, article := range articles {
		result = append(result, &models.ArticleInfo{
			ID:          article.ID,
			Name:        article.Name,
			Text:        article.Text,
			Complexity:  article.Complexity,
			ReadingTime: strconv.Itoa(article.ReadingTime),
			Tags:        article.Tags,
			Likes:       article.Likes,
			LikedByUser: article.LikedByUser,
		})
	}
	return &models.ArticlesPagination{
		Items: result,
		PageInfo: &models.PaginationInfo{
			Page:            pagination.Page,
			PageSize:        pagination.PageSize,
			HasNextPage:     pagination.HasNextPage,
			HasPreviousPage: pagination.HasPreviousPage,
		},
	}, nil
}

// Article is the resolver for the article field.
func (r *queryResolver) Article(ctx context.Context, id int) (*models.ArticleInfo, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	articleInfo, err := r.Scrapping.GetArticleInfoById(ctx, userId, id)
	if err != nil {
		return nil, err
	}
	return &models.ArticleInfo{
		ID:          articleInfo.ID,
		Name:        articleInfo.Name,
		Text:        articleInfo.Text,
		Complexity:  articleInfo.Complexity,
		ReadingTime: strconv.Itoa(articleInfo.ReadingTime),
		Tags:        articleInfo.Tags,
		Likes:       articleInfo.Likes,
		LikedByUser: articleInfo.LikedByUser,
	}, nil
}

// ArticlesByIds is the resolver for the articlesByIds field.
func (r *queryResolver) ArticlesByIds(ctx context.Context, ids []int) ([]*models.ArticleInfo, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	articles, err := r.Scrapping.GetArticlesByIds(ctx, userId, ids)
	if err != nil {
		return nil, err
	}
	articlesInfo := make([]*models.ArticleInfo, 0, len(articles))
	for _, article := range articles {
		articlesInfo = append(articlesInfo, &models.ArticleInfo{
			ID:          article.ID,
			Name:        article.Name,
			Text:        article.Text,
			Complexity:  article.Complexity,
			ReadingTime: strconv.Itoa(article.ReadingTime),
			Tags:        article.Tags,
			Likes:       article.Likes,
			LikedByUser: article.LikedByUser,
		})
	}
	return articlesInfo, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, pageSize int) ([]*models.ArticleInfo, error) {
	userId, err := middlewares.GetUserId(ctx)
	if err != nil {
		return nil, err
	}
	articles, err := r.Scrapping.Search(ctx, userId, query, pageSize)
	if err != nil {
		return nil, err
	}
	articlesInfo := make([]*models.ArticleInfo, 0, len(articles))
	for _, article := range articles {
		articlesInfo = append(articlesInfo, &models.ArticleInfo{
			ID:          article.ID,
			Name:        article.Name,
			Text:        article.Text,
			Complexity:  article.Complexity,
			ReadingTime: strconv.Itoa(article.ReadingTime),
			Tags:        article.Tags,
			Likes:       article.Likes,
			LikedByUser: article.LikedByUser,
		})
	}
	return articlesInfo, nil
}

// Mutation returns server.MutationResolver implementation.
func (r *Resolver) Mutation() server.MutationResolver { return &mutationResolver{r} }

// Query returns server.QueryResolver implementation.
func (r *Resolver) Query() server.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
